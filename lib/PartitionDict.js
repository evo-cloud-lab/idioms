var Class = require('js-class'),
    Range = require('evo-elements').Range,

    Partitioner = require('./Partitioner');

/** @class
 * @description A dictionary storing objects by partitions
 *
 * With PartitionDict, objects can insert/update/remove quickly
 * based on partition.
 */
var PartitionDict = Class(process.EventEmitter, {
    constructor: function (partitionMonitor, handler) {
        this._parts = [];
        this._range = new Range();
        this._listener = this.applyPartitionChanges.bind(this);
        if (typeof(partitionMonitor) == 'function') {
            handler = partitionMonitor;
            partitionMonitor = null;
        }
        partitionMonitor && this.watch(partitionMonitor);
        handler && this.on('update', handler);
    },

    /** @property
     * @description get watched PartitionMonitor
     */
    get monitor () {
        return this._monitor;
    },

    /** @property
     * @description get current assigned partition ranges
     * @returns Range
     */
    get parts () {
        return this._range;
    },

    /** @function
     * @description set assigned partition ranges
     */
    assign: function (part, count) {
        this._range = Range.parse(part, count);
        if (!this._range) {
            throw new Error('Invalid range');
        }
        return this;
    },

    /** @function
     * @description put an object into the dictionary
     *
     * If the key doesn't fit into the assigned range, nothing
     * happens and returns false.
     */
    add: function (key, obj) {
        var part = Partitioner.part(key);
        if (this._range.cover(part)) {
            var dict = this._parts[part];
            dict || (dict = this._parts[part] = {});
            dict[key] = obj;
            return true;
        }
        return false;
    },

    /** @function
     * @description remove an object by key
     */
    remove: function (key) {
        var part = Partitioner.part(key);
        var dict = this._parts[part];
        var obj = dict && dict[key];
        if (dict) {
            delete dict[key];
            if (Object.keys(dict).length == 0) {
                delete this._parts[part];
            }
        }
        return obj;
    },

    /** @function
     * @description lookup an object by key
     */
    find: function (key) {
        var part = Partitioner.part(key);
        var dict = this._parts[part];
        return dict && dict[key];
    },

    /** @function
     * @description retrieve <key, obj> pairs of specified partitions or all partitions
     * @returns object maps <key, obj>
     */
    select: function (part, count) {
        var parts;
        if (part != null) {
            count == null && (count = 1);
            if (count > 1) {
                var range = Range.parse(part, count);
                parts = Object.keys(this._parts).filter(function (key) {
                    return range.cover(key);
                });
            } else {
                parts = [part];
            }
        } else {
            parts = Object.keys(this._parts);
        }
        return parts.reduce(function (result, part) {
            var dict = this._parts[part];
            if (dict) {
                for (var key in dict) {
                    result[key] = dict[key];
                }
            }
            return result;
        }.bind(this), {});
    },

    /** @function
     * @description adjust assigned partitions with changes generated by PartitionMonitor
     * @returns array of partitions with objects to be removed
     */
    applyPartitionChanges: function (changes) {
        var removals = [];
        if (changes.shrink) {
            var parts = Object.keys(this._parts).filter(function (part) {
                    return changes.shrink.some(function (shrink) { return shrink.cover(part); });
                });
            removals = parts.map(function (part) {
                var dict = this._parts[part];
                delete this._parts[part];
                return dict;
            }, this);
            this._range = Range.parse(changes.range);
        }
        this.emit('update', removals, changes, this);
        return removals;
    },

    /** @function
     * @description watch a PartitionMonitor for changes
     */
    watch: function (partitionMonitor, handler) {
        this.unwatch();
        (this._monitor = partitionMonitor)
            .on('partition', this._listener);
        handler && this.on('update', handler);
        return this;
    },

    /** @function
     * @description unwatch a PartitionMonitor
     */
    unwatch: function () {
        if (this._monitor) {
            this._monitor.removeListener('partition', this._listener);
            delete this._monitor;
        }
        return this;
    },

    /** @function
     * @description commit partition changes to monitor
     */
    commitToMonitor: function () {
        if (this._monitor) {
            this._monitor.commit(this._range);
        }
        return this;
    }
});

module.exports = PartitionDict;
